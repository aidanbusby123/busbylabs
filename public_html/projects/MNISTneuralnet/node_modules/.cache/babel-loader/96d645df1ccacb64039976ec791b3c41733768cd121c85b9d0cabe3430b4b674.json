{"ast":null,"code":"import React,{useRef,useState,useEffect}from'react';import axios from'axios';import{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";function App(){const canvasRef=useRef(null);const[prediction,setPrediction]=useState(null);const[probabilities,setProbabilities]=useState([]);// Store probabilities for each digit\nconst blockSize=20;// Fixed block size\nconst brushSize=2*blockSize;// Brush size is 2x the block size\n// Function to clear the canvas\nconst clearCanvas=()=>{const canvas=canvasRef.current;const ctx=canvas.getContext('2d');ctx.fillStyle='white';// Set the canvas background to white\nctx.fillRect(0,0,canvas.width,canvas.height);// Fill the canvas with white\n};// Clear the canvas on initial load\nuseEffect(()=>{clearCanvas();},[]);// Function to send the canvas data to the backend\nconst predictDigit=async()=>{const canvas=canvasRef.current;const ctx=canvas.getContext('2d');// Get the image data from the canvas\nconst imageData=ctx.getImageData(0,0,canvas.width,canvas.height);const grayscaleData=[];// Convert the canvas data to grayscale and normalize\nfor(let i=0;i<imageData.data.length;i+=4){// Convert to grayscale (average of R, G, B)\nconst grayscale=(imageData.data[i]+imageData.data[i+1]+imageData.data[i+2])/3;// Normalize: 0 (white) to 1 (black)\nconst normalized=1-grayscale/255;// Invert so 0 is white and 1 is black\ngrayscaleData.push(normalized);}console.log(\"Grayscale Data:\",grayscaleData);// Debugging\n// Resize the image to 28x28 (MNIST format)\nconst resizedData=[];const scale=canvas.width/28;for(let y=0;y<28;y++){for(let x=0;x<28;x++){const startX=Math.floor(x*scale);const startY=Math.floor(y*scale);const endX=Math.floor((x+1)*scale);const endY=Math.floor((y+1)*scale);// Average the grayscale values in the block\nlet sum=0;let count=0;for(let yy=startY;yy<endY;yy++){for(let xx=startX;xx<endX;xx++){const pixelIndex=yy*canvas.width+xx;sum+=grayscaleData[pixelIndex];count++;}}resizedData.push(sum/count);// Average grayscale value for the block\n}}console.log(\"Resized Data:\",resizedData);// Debugging\ntry{// Send the image data to the backend\nconst response=await axios.post('https://busbylabs.com/projects/MNISTneuralnet/predict',{image:resizedData});// Extract prediction and probabilities\nsetPrediction(response.data.digit);setProbabilities(response.data.probabilities);// Store probabilities for rendering\n}catch(error){console.error('Error predicting digit:',error);}};// Function to draw blocks on the canvas\nconst drawBlock=e=>{const canvas=canvasRef.current;const ctx=canvas.getContext('2d');const rect=canvas.getBoundingClientRect();// Get the mouse position relative to the canvas\nconst x=e.clientX-rect.left;const y=e.clientY-rect.top;// Calculate the top-left corner of the block\nconst x1=Math.floor(x/blockSize)*blockSize;const y1=Math.floor(y/blockSize)*blockSize;// Calculate the bottom-right corner of the block (brush size is 2 * blockSize)\nconst x2=x1+brushSize;const y2=y1+brushSize;console.log(\"Drawing block at (\".concat(x1,\", \").concat(y1,\") to (\").concat(x2,\", \").concat(y2,\")\"));// Debugging\n// Draw a filled rectangle (block)\nctx.fillStyle='black';ctx.fillRect(x1,y1,x2-x1,y2-y1);};return/*#__PURE__*/_jsxs(\"div\",{style:{textAlign:'center'},children:[/*#__PURE__*/_jsx(\"h1\",{children:\"Draw a Digit\"}),/*#__PURE__*/_jsx(\"canvas\",{ref:canvasRef,width:560// Fixed canvas size to match Tkinter\n,height:560// Fixed canvas size to match Tkinter\n,style:{border:'1px solid black'},onMouseMove:e=>{if(e.buttons!==1)return;// Only draw when the left mouse button is pressed\ndrawBlock(e);},onMouseDown:e=>drawBlock(e)// Draw on mouse down\n}),/*#__PURE__*/_jsxs(\"div\",{children:[/*#__PURE__*/_jsx(\"button\",{onClick:predictDigit,children:\"Predict\"}),/*#__PURE__*/_jsx(\"button\",{onClick:clearCanvas,children:\"Clear\"})]}),prediction!==null&&/*#__PURE__*/_jsxs(\"h2\",{children:[\"Predicted Digit: \",prediction]}),probabilities.length>0&&/*#__PURE__*/_jsxs(\"div\",{style:{marginTop:'20px'},children:[/*#__PURE__*/_jsx(\"h3\",{children:\"Prediction Probabilities\"}),/*#__PURE__*/_jsx(\"div\",{style:{display:'flex',justifyContent:'center',gap:'10px'},children:probabilities.map((prob,index)=>/*#__PURE__*/_jsxs(\"div\",{style:{textAlign:'center'},children:[/*#__PURE__*/_jsx(\"div\",{style:{width:'30px',height:\"\".concat(prob*100,\"%\"),// Scale height based on probability\nbackgroundColor:'blue',margin:'0 auto'}}),/*#__PURE__*/_jsx(\"span\",{children:index})]},index))})]})]});}export default App;","map":{"version":3,"names":["React","useRef","useState","useEffect","axios","jsx","_jsx","jsxs","_jsxs","App","canvasRef","prediction","setPrediction","probabilities","setProbabilities","blockSize","brushSize","clearCanvas","canvas","current","ctx","getContext","fillStyle","fillRect","width","height","predictDigit","imageData","getImageData","grayscaleData","i","data","length","grayscale","normalized","push","console","log","resizedData","scale","y","x","startX","Math","floor","startY","endX","endY","sum","count","yy","xx","pixelIndex","response","post","image","digit","error","drawBlock","e","rect","getBoundingClientRect","clientX","left","clientY","top","x1","y1","x2","y2","concat","style","textAlign","children","ref","border","onMouseMove","buttons","onMouseDown","onClick","marginTop","display","justifyContent","gap","map","prob","index","backgroundColor","margin"],"sources":["/home/aidan/busbylabs/public_html/projects/MNISTneuralnet/src/App.js"],"sourcesContent":["import React, { useRef, useState, useEffect } from 'react';\nimport axios from 'axios';\n\nfunction App() {\n  const canvasRef = useRef(null);\n  const [prediction, setPrediction] = useState(null);\n  const [probabilities, setProbabilities] = useState([]); // Store probabilities for each digit\n\n  const blockSize = 20; // Fixed block size\n  const brushSize = 2 * blockSize; // Brush size is 2x the block size\n\n  // Function to clear the canvas\n  const clearCanvas = () => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    ctx.fillStyle = 'white'; // Set the canvas background to white\n    ctx.fillRect(0, 0, canvas.width, canvas.height); // Fill the canvas with white\n  };\n\n  // Clear the canvas on initial load\n  useEffect(() => {\n    clearCanvas();\n  }, []);\n\n  // Function to send the canvas data to the backend\n  const predictDigit = async () => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n\n    // Get the image data from the canvas\n    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    const grayscaleData = [];\n\n    // Convert the canvas data to grayscale and normalize\n    for (let i = 0; i < imageData.data.length; i += 4) {\n      // Convert to grayscale (average of R, G, B)\n      const grayscale = (imageData.data[i] + imageData.data[i + 1] + imageData.data[i + 2]) / 3;\n\n      // Normalize: 0 (white) to 1 (black)\n      const normalized = 1 - grayscale / 255; // Invert so 0 is white and 1 is black\n      grayscaleData.push(normalized);\n    }\n\n    console.log(\"Grayscale Data:\", grayscaleData); // Debugging\n\n    // Resize the image to 28x28 (MNIST format)\n    const resizedData = [];\n    const scale = canvas.width / 28;\n    for (let y = 0; y < 28; y++) {\n      for (let x = 0; x < 28; x++) {\n        const startX = Math.floor(x * scale);\n        const startY = Math.floor(y * scale);\n        const endX = Math.floor((x + 1) * scale);\n        const endY = Math.floor((y + 1) * scale);\n\n        // Average the grayscale values in the block\n        let sum = 0;\n        let count = 0;\n        for (let yy = startY; yy < endY; yy++) {\n          for (let xx = startX; xx < endX; xx++) {\n            const pixelIndex = yy * canvas.width + xx;\n            sum += grayscaleData[pixelIndex];\n            count++;\n          }\n        }\n        resizedData.push(sum / count); // Average grayscale value for the block\n      }\n    }\n\n    console.log(\"Resized Data:\", resizedData); // Debugging\n\n    try {\n      // Send the image data to the backend\n      const response = await axios.post('https://busbylabs.com/projects/MNISTneuralnet/predict', {\n        image: resizedData,\n      });\n\n      // Extract prediction and probabilities\n      setPrediction(response.data.digit);\n      setProbabilities(response.data.probabilities); // Store probabilities for rendering\n    } catch (error) {\n      console.error('Error predicting digit:', error);\n    }\n  };\n\n  // Function to draw blocks on the canvas\n  const drawBlock = (e) => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    const rect = canvas.getBoundingClientRect();\n\n    // Get the mouse position relative to the canvas\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n\n    // Calculate the top-left corner of the block\n    const x1 = Math.floor(x / blockSize) * blockSize;\n    const y1 = Math.floor(y / blockSize) * blockSize;\n\n    // Calculate the bottom-right corner of the block (brush size is 2 * blockSize)\n    const x2 = x1 + brushSize;\n    const y2 = y1 + brushSize;\n\n    console.log(`Drawing block at (${x1}, ${y1}) to (${x2}, ${y2})`); // Debugging\n\n    // Draw a filled rectangle (block)\n    ctx.fillStyle = 'black';\n    ctx.fillRect(x1, y1, x2 - x1, y2 - y1);\n  };\n\n  return (\n    <div style={{ textAlign: 'center' }}>\n      <h1>Draw a Digit</h1>\n      <canvas\n        ref={canvasRef}\n        width={560} // Fixed canvas size to match Tkinter\n        height={560} // Fixed canvas size to match Tkinter\n        style={{ border: '1px solid black' }}\n        onMouseMove={(e) => {\n          if (e.buttons !== 1) return; // Only draw when the left mouse button is pressed\n          drawBlock(e);\n        }}\n        onMouseDown={(e) => drawBlock(e)} // Draw on mouse down\n      />\n      <div>\n        <button onClick={predictDigit}>Predict</button>\n        <button onClick={clearCanvas}>Clear</button>\n      </div>\n      {prediction !== null && <h2>Predicted Digit: {prediction}</h2>}\n\n      {/* Render probability bars */}\n      {probabilities.length > 0 && (\n        <div style={{ marginTop: '20px' }}>\n          <h3>Prediction Probabilities</h3>\n          <div style={{ display: 'flex', justifyContent: 'center', gap: '10px' }}>\n            {probabilities.map((prob, index) => (\n              <div key={index} style={{ textAlign: 'center' }}>\n                <div\n                  style={{\n                    width: '30px',\n                    height: `${prob * 100}%`, // Scale height based on probability\n                    backgroundColor: 'blue',\n                    margin: '0 auto',\n                  }}\n                ></div>\n                <span>{index}</span>\n              </div>\n            ))}\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n\nexport default App;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}